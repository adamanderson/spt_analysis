---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Analysis for 2019 LTD Proceedings: W206 performance

```python
import numpy as np
import matplotlib.pyplot as plt
import pickle
from glob import glob
import re
import pydfmux
import pydfmux.analysis.utils.pixel_tools as pxtools
from spt3g import core, calibration, dfmux
import os.path
import adama_utils
import pandas as pd
from optical_eff import calc_psat_data, fit_efficiency, PsatofT_coldload
from scipy.optimize import curve_fit
import pydfmux
```

```python
hwm_pole = pydfmux.load_session(open('/home/adama/SPT/hardware_maps_southpole/2019'
                                     '/hwm_pole/hwm.yaml'))['hardware_map']
```

## Yield
Daniel reports statistics for the following yield categories:
* wired bolometers
* room temperature connectivity
* identified resonance
* biased
* optically responsive

Let's estimate similar statistics just for W206.


### total detectors
We only measure detectors that are wired, so let's take the denominator to be only the detectors that we can measure.

```python
n_detectors = 66*24 - 6*2 # subtract off channels that go to alignment pixels
print('total number of detectors = {}'.format(n_detectors))
```

### warm pinout

```python
n_opens = 130 # from spreadshee on trac wiki: compare_all_wafers_to_last_year_19Nov2018.xlsx
n_connected = n_detectors - n_opens
print('total detectors passing warm pinout = {:.0f} ({:.1f}%)'\
      .format(n_connected,\
              100 * n_connected / n_detectors))
```

### identified resonances

```python
hwm_fname = '/home/adama/SPT/hardware_maps_southpole/2019/hwm_pole/hwm.yaml'
hwm_pole = pydfmux.load_session(open(hwm_fname, 'r'))['hardware_map']
```

```python
bolos_w206 = hwm_pole.query(pydfmux.Bolometer)\
                     .join(pydfmux.ChannelMapping, pydfmux.Wafer)\
                     .filter(pydfmux.Wafer.name=='w206')
freqs = [b.channel_map.lc_channel.frequency \
         for b in bolos_w206 \
         if b.channel_map.lc_channel.frequency > 1.e5]
n_resonances = len(freqs)
print('number of bolometers with matched resonances = {:.0f} ({:.1f}%)'\
      .format(n_resonances, 100 * n_resonances / n_detectors))
```

### tuned detectors

```python
tuned_fnames = []
for dirstub in ['201905', '201906']:
    fnames = glob('/big_scratch/pydfmux_output/{}*/'
                  '*drop_bolos_*/data/TOTAL_DATA.pkl'.format(dirstub))
    tuned_fnames += [fname for fname in fnames if 'tweak' not in fname]

```

```python
ntuned = {}
for fname in tuned_fnames:
    with open(fname, 'rb') as f:
        print(fname)
        ntuned[fname] = 0
        
        d = pickle.load(f)
        for mod in d.keys():
            if type(d[mod])==dict and 'results_summary' in d[mod].keys():
                physical_names = [d[mod]['subtargets'][chan]['physical_name'] \
                              for chan in d[mod]['subtargets'].keys()]
                if np.any(['w206' in physname for physname in physical_names]):
                    ntuned[fname] += d[mod]['results_summary']['ntuned']
```

```python
n_tuned_median = np.median(list(ntuned.values()))
print('median number of tuned bolometers = {:.0f} ({:.1f}%)'\
      .format(n_tuned_median, 100 * n_tuned_median / n_detectors))
```

What accounts for the large drop in number of detectors between showing a resonance and being tuned? The most likely cut is the HR10 network analysis cut. Let's calculate the number of these detectors that are on w206.

```python
df = pd.read_csv('/home/adama/SPT/hardware_maps_southpole/2019/global/exclude/warmVcold_exclude_hr10.csv')
bolos_w206 = hwm_pole.query(pydfmux.Bolometer)\
                     .join(pydfmux.ChannelMapping, pydfmux.Wafer)\
                     .filter(pydfmux.Wafer.name == 'w206')
bolonames_w206 = [b.name for b in bolos_w206]
bolonames_w206_hr10 = [bolo for bolo in df['name'] if bolo in bolonames_w206]
print('# of bolos removed by HR10 cut = {:.1f} ({:.1f}%)'\
      .format(len(bolonames_w206_hr10),
              100 * len(bolonames_w206_hr10) / n_detectors))
```

### optically responsive
For simplicity, let's bypass the autoprocessing data and just pull numbers from the data quality monitoring, which uses a S/N cut for 20 (median S/N is 200, so this is a low bar for optical responsitivity).

```python
fnames = glob('/spt/data/rsync/spt_dq_data/201905*_data_cache.pkl')

alivebolos = {90:[], 150:[], 220:[]}

for fname in fnames:
    with open(fname, 'rb') as f:
        d = pickle.load(f)
    for obsid in d['calibrator'].keys():
        if 'AliveBolosCal_4Hz' in d['calibrator'][obsid].keys():
            alivebolos[90].append(d['calibrator'][obsid]['AliveBolosCal_4Hz']['w206'][90])
            alivebolos[150].append(d['calibrator'][obsid]['AliveBolosCal_4Hz']['w206'][150])
            alivebolos[220].append(d['calibrator'][obsid]['AliveBolosCal_4Hz']['w206'][220])

for band in alivebolos:
    print('# bolos with calibrator S/N > 20 at {} GHz = {:.0f}'.format(band, np.median(alivebolos[band])))
total_alive = np.sum([np.median(alivebolos[band]) for band in alivebolos])
print('# total bolos alive = {:.0f} ({:.1f}%)'\
      .format(total_alive, 100*total_alive / n_detectors))
```

## Time Constants

```python
tau_dir = '/spt/user/panz/data/time_constant_results/2019/'
fnames = glob(os.path.join(tau_dir, 'time_const*_el_*deg.pkl'))
```

```python
# get the bolometer properties
boloprops = list(core.G3File('/spt/data/bolodata/fullrate/calibrator/76410413'
                             '/offline_calibration.g3'))[0]["BolometerProperties"]
```

```python
tau = {}
tau_el67 = {}

for fname in fnames:
    with open(fname, 'rb') as f:
        d = pickle.load(f)
        
    for bolo in d.keys():
        if bolo in boloprops and boloprops[bolo].wafer_id == 'w206':
            if bolo not in tau.keys():
                tau[bolo] = {}
            tau[bolo][os.path.basename(fname).lstrip('time_const')[:8]] = d[bolo][0]
            
            if '67deg' in fname:
                if bolo not in tau_el67.keys():
                    tau_el67[bolo] = {}
                tau_el67[bolo][os.path.basename(fname).lstrip('time_const')[:8]] = d[bolo][0]
```

```python
for jband, band in enumerate([90, 150, 220]):
    plt.figure(jband+1)
    tau_plot1 = np.array([np.median(tau[bolo]['73570880']) for bolo in tau \
                         if boloprops[bolo].band/core.G3Units.GHz==band and \
                         '73570880' in tau[bolo].keys()])
    tau_plot2 = np.array([np.median(tau[bolo]['78191553']) for bolo in tau \
                         if boloprops[bolo].band/core.G3Units.GHz==band and \
                         '78191553' in tau[bolo].keys()])
    _ = plt.hist(1e3*tau_plot1, bins=np.linspace(0, 12, 41),
                 histtype='step', label='{} GHz'.format(band),
                 linestyle='--', color='C{}'.format(jband))
    _ = plt.hist(1e3*tau_plot2, bins=np.linspace(0, 12, 41),
                 histtype='step', label='{} GHz'.format(band),
                 color='C{}'.format(jband))
plt.legend()
```

```python
bandlabel = {90:'95', 150:'150', 220:'220'}
plt.figure(figsize=(5,3))
for jband, band in enumerate([90, 150, 220]):
    tau_plot = np.array([np.median([tau_el67[bolo][obsid] for obsid in tau_el67[bolo].keys()]) for bolo in tau_el67 \
                         if boloprops[bolo].band/core.G3Units.GHz==band and \
                         '78121319' in tau[bolo].keys()])
    print(np.mean(tau_plot)*1000)
    _ = plt.hist(1e3*tau_plot, bins=np.linspace(0, 12, 26),
                 histtype='stepfilled', label='{} GHz'.format(bandlabel[band]),
                 alpha=0.5, color='C{}'.format(jband))
    _ = plt.hist(1e3*tau_plot, bins=np.linspace(0, 12, 26),
                 histtype='step', linewidth=1.5, color='C{}'.format(jband))
for tick in plt.gca().xaxis.get_major_ticks():
    tick.label.set_fontsize(14)
for tick in plt.gca().yaxis.get_major_ticks():
    tick.label.set_fontsize(14)
plt.legend(frameon=False, fontsize=12)
plt.xlabel('time constant [msec]', fontsize=14)
plt.ylabel('bolometers', fontsize=14)
plt.tight_layout()
plt.savefig('figures/tau.pdf')
```

```python
bandlabel = {90:'95', 150:'150', 220:'220'}
plt.figure(figsize=(5,3))
for jband, band in enumerate([90, 150, 220]):
    tau_plot = np.array([np.median([tau_el67[bolo][obsid] for obsid in tau_el67[bolo].keys()]) for bolo in tau_el67 \
                         if boloprops[bolo].band/core.G3Units.GHz==band and \
                         '78121319' in tau[bolo].keys()])
    print(np.mean(tau_plot)*1000)
    _ = plt.hist(1e3*tau_plot, bins=np.linspace(0, 12, 26),
                 histtype='stepfilled', label='{} GHz'.format(bandlabel[band]),
                 alpha=0.5, color='C{}'.format(jband))
    _ = plt.hist(1e3*tau_plot, bins=np.linspace(0, 12, 26),
                 histtype='step', linewidth=1.5, color='C{}'.format(jband))

plt.plot([0.7, 0.7], [0, 130], 'C3--')
plt.ylim([0,130])
for tick in plt.gca().xaxis.get_major_ticks():
    tick.label.set_fontsize(16)
for tick in plt.gca().yaxis.get_major_ticks():
    tick.label.set_fontsize(16)
plt.legend(frameon=False)
plt.xlabel('time constant [msec]', fontsize=16)
plt.ylabel('bolometers', fontsize=16)
plt.tight_layout()
plt.savefig('figures/tau_poster.pdf')
```

## Noise vs. power
Attempt to reproduce Fig. 3 of 1811.08287. Let's first figure out how to get the Joule power from the housekeeping data.

```python
fname_joule = '/spt/user/adama/20190630_ltd/fullrate/joulepower_noise_77198612.g3'
djoule = list(core.G3File(fname_joule))
boloprops = djoule[0]["BolometerProperties"]
dautoproc = list(core.G3File('/spt/user/production/calibration/noise/77198612.g3'))[0]
```

```python
PJ = {90:[], 150:[], 220:[]}
NET = {90:[], 150:[], 220:[]}
NEP = {90:[], 150:[], 220:[]}

for bolo in boloprops.keys():
    if boloprops[bolo].wafer_id == 'w206' and \
       bolo in djoule[1]['AvgPower'].keys() and \
       bolo in dautoproc["NET_3.0Hz_to_5.0Hz"] and \
       boloprops[bolo].band/core.G3Units.GHz in PJ.keys():
        PJ[boloprops[bolo].band/core.G3Units.GHz].append(djoule[1]['AvgPower'][bolo] / (1e-12*core.G3Units.watt))
        NET[boloprops[bolo].band/core.G3Units.GHz].append(dautoproc["NET_3.0Hz_to_5.0Hz"][bolo] / \
                                                          (1e-6*core.G3Units.kelvin * np.sqrt(core.G3Units.second)))
```

```python
for band in PJ:
    _ = plt.hist(PJ[band], bins=np.linspace(2, 15, 51), histtype='step', label='{} GHz'.format(band))
plt.legend(frameon=False)
plt.xlabel('$P_J$ [pW]')
plt.ylabel('bolometers')
plt.tight_layout()
```

```python
for band in PJ:
    plt.plot(PJ[band], NET[band], '.')
plt.legend(frameon=False)
plt.xlabel('$P_J$ [pW]')
plt.ylabel('bolometers')
plt.tight_layout()
plt.ylim([0, 2500])
```

```python
joule_path = '/spt/user/adama/20190630_ltd/fullrate/'
fnames = glob(os.path.join(joule_path, '*'))
fnames = np.sort(fnames)

PJ = {}
NET = {}
NEP = {}
#90:[], 150:[], 220:[]

for fname in fnames:
    obsid = os.path.basename(fname).split('_')[2].split('.')[0]
    print(obsid)
    djoule = list(core.G3File(fname))
    boloprops = djoule[0]["BolometerProperties"]
    dautoproc = list(core.G3File('/spt/user/production/calibration/'
                                 'noise/{}.g3'.format(obsid)))[0]
    
    PJ[obsid] = {90:[], 150:[], 220:[]}
    NET[obsid] = {90:[], 150:[], 220:[]}
    NEP[obsid] = {90:[], 150:[], 220:[]}
    for bolo in boloprops.keys():
        if boloprops[bolo].wafer_id == 'w206' and \
           bolo in djoule[1]['AvgPower'].keys() and \
           bolo in dautoproc["NET_3.0Hz_to_5.0Hz"] and \
           boloprops[bolo].band/core.G3Units.GHz in PJ[obsid].keys():
            PJ[obsid][boloprops[bolo].band/core.G3Units.GHz]\
                .append(djoule[1]['AvgPower'][bolo] / (1e-12*core.G3Units.watt))
            NET[obsid][boloprops[bolo].band/core.G3Units.GHz]\
                .append(dautoproc["NET_3.0Hz_to_5.0Hz"][bolo] / \
                        (1e-6*core.G3Units.kelvin * np.sqrt(core.G3Units.second)))
            NEP[obsid][boloprops[bolo].band/core.G3Units.GHz]\
                .append(dautoproc["NEP_3.0Hz_to_5.0Hz"][bolo] / \
                        (1e-18*core.G3Units.watt / np.sqrt(core.G3Units.Hz)))
```

```python
for band in [90, 150, 220]:
    PJ_median = np.array([np.median(PJ[obsid][band]) \
                          for obsid in PJ if int(obsid)>72000000])
    NET_median = np.array([np.median(NET[obsid][band]) \
                           for obsid in PJ if int(obsid)>72000000])
    plt.plot(PJ_median, NET_median, '.')
    plt.axis([4, 10, 0, 2500])
```

```python
for jband, band in enumerate([90, 150, 220]):
    plt.figure(jband+1)
    PJ_plot = np.hstack([PJ[obsid][band] for obsid in PJ])
    NET_plot = np.hstack([NET[obsid][band] for obsid in PJ])
    
    binedges = np.linspace(4,9,26)
    bincenters = (binedges[:-1] + binedges[1:]) / 2
    ind = np.digitize(PJ_plot, bins=binedges)
    NET_median = np.array([np.median(NET_plot[(ind==jbin) & (NET_plot<3000)]) \
                             for jbin in range(len(bincenters))])
    NET_yerr_up = np.array([np.percentile(NET_plot[(ind==jbin) & (NET_plot<3000)], 84) \
                   for jbin in range(len(bincenters))])
    NET_yerr_down = np.array([np.percentile(NET_plot[(ind==jbin) & (NET_plot<3000)], 16) \
                   for jbin in range(len(bincenters))])
    NET_err = np.array([np.std(NET_plot[(ind==jbin) & (NET_plot<3000)]) \
                        / np.sqrt(len(NET_plot[(ind==jbin) & (NET_plot<3000)])) \
                      for jbin in range(len(bincenters))]) 
    
    
    plt.plot(PJ_plot, NET_plot, '.', markersize=0.1)
    plt.errorbar(bincenters, NET_median, NET_err, color='k')
    plt.axis([0, 15, 0, 2200])
```

```python
from scipy.stats import gaussian_kde

net_modes = []
pj_modes = []
obsid_list = []
for obsid in NET.keys():
    net_plot = np.linspace(0,3000,1000)
    pj_plot = np.linspace(0,15,1000)
    net_analyze = np.array(NET[obsid][220])
    pj_analyze = np.array(PJ[obsid][220])
    
    try:
        kernel = gaussian_kde(net_analyze[np.isfinite(net_analyze)])
        net_modes.append(net_plot[np.argmax(kernel(net_plot))])
        obsid_list.append(int(obsid))
        
        kernel = gaussian_kde(pj_analyze[np.isfinite(pj_analyze)])
        pj_modes.append(pj_plot[np.argmax(kernel(pj_plot))])
    except:
        pass
```

```python
plt.plot(pj_modes, net_modes, '.')
# plt.axis([5, 9, 1000, 2500])
```

```python
plt.plot(obsid_list, pj_modes, '.')
```

## $R_n$ and $R_p$

```python
with open('/home/adama/SPT/spt_analysis/20190630_ltd/run33/RT_slots123/fnal_run33__RT_data.pkl', 'rb') as f:
    d = pickle.load(f, encoding='latin1')
with open('res_tf.pkl', 'rb') as f:
    tf = pickle.load(f)
```

```python
Rn_fnal = np.array([d['Rn'][bolo] for bolo in d['Rn']])
Rp_fnal = np.array([d['Rp'][bolo] for bolo in d['Rn']])
fbias_fnal = np.array([d['bias_freq'][bolo] for bolo in d['Rn']])
Tc_fnal = np.array([d['Tc_average'][bolo] for bolo in d['Tc_average']])

fbias_fnal = fbias_fnal[np.isfinite(Rn_fnal)]
Rp_fnal = Rp_fnal[np.isfinite(Rn_fnal)]
Rn_fnal = Rn_fnal[np.isfinite(Rn_fnal)]
```

To deal with the fact that we don't have measurements of $R_p$ on every detector in the pole data, let's estimate an average frequency-dependent stray impedance from the lab data, which we can subtract off from each detector.

```python
Rp_tofit = Rp_fnal[(Rp_fnal<0.7) & (Rp_fnal>0) & (fbias_fnal<5.5e6)]
fbias_tofit = fbias_fnal[(Rp_fnal<0.7) & (Rp_fnal>0) & (fbias_fnal<5.5e6)]
plt.plot(fbias_tofit, Rp_tofit, '.')
Rp_coeff = np.polyfit(fbias_tofit, Rp_tofit, deg=8)

def Rp_model(f):
    f = np.asarray(f)
    Rp = np.zeros(f.shape)
    Rp[f<min(fbias_tofit)] = np.polyval(Rp_coeff, min(fbias_tofit))
    Rp[f>max(fbias_tofit)] = np.polyval(Rp_coeff, max(fbias_tofit))
    Rp[(f>min(fbias_tofit)) & (f<max(fbias_tofit))] = \
        np.polyval(Rp_coeff, f[(f>min(fbias_tofit)) & (f<max(fbias_tofit))])
    return Rp
    
fbias_fit = np.linspace(1200000, 6000000)
plt.plot(fbias_fit, Rp_model(fbias_fit))
plt.savefig('Rp_vs_fbias.png', dpi=200)
np.savetxt('Rp_vs_fbias_data.txt',
           np.vstack([fbias_fit, Rp_model(fbias_fit)]).T)
```

Our use of a single, frequency-dependent value for $R_p$ introduces some residual variance in the estimate of $R_n$. Let's try to estimate that systematic uncertainty by computing the residuals between the lab $R_p$ data and our model.

```python
residual = Rp_model(fbias_tofit) - Rp_tofit
plt.plot(fbias_tofit, residual, '.')
plt.xlabel('frequency [Hz]')
plt.ylabel('residual in $R_p$ fit')
plt.title('std of residual = {:.3f} Ohm'.format(np.std(residual)))
plt.tight_layout()
```

Below is the correction factor for the normal resistance that was estimated as a function of LC index by Daniel Dutcher. This is the same correction factor, $c(i(f))$ that is discussed in Appendix A of his LTD proceedings 1809.00033. To apply it, we compute
$$
R_n^{corr} = \frac{R^{meas}_{total}}{c(i)} - R^{meas}_p,
$$
where $R^{meas}_{total}$ is the measured total resistance reported by pydfmux, $R^{meas}_p$ is the measured parasitic resistance reported by pydfmux, and $c$ is Daniel's correction factor, which is a function of the LC index $i$ corresponding to the channel of interest.

Note that Daniel actually computed his corrected resistance as
$$
R_n^{corr} = \frac{R^{meas}_{total} - R^{meas}_p}{c(i)}.
$$
These two estimators give very similar results, but I think the former is slightly better. The reason is that we believe the correction factor to be a result of the parasitic capacitance to ground at the LC, which occurs before the TES. This means that the parasitic and the TES act like a current divider. When the TES resistance is large relative to the parasitic, a large fraction of the current gets shunted away from the SQUID causing the measured "impedance" to appear large. When the TES is superconducting, the relative size of the correction is much smaller. The fact that we don't see any obvious splitting of the impedance by LC orientation in the preceding figure suggests that the correction factor is small when the TES is superconducting. The former correction prescription should be closer to this case.

```python
plt.plot(tf, '.')
```

In order to apply the resistance correction, we need to know the LC index of a resonator. We don't know this perfectly from the Fermilab data because the matching is less reliable than at pole. As a result, we take the normal resistance measurements from a representative pole tuning, and extract the LC index from the hardware map.

```python
fname_Rn_pole = '/big_scratch/pydfmux_output/20190618/20190619_011150_drop_bolos_228/data/TOTAL_DATA.pkl'
with open(fname_Rn_pole, 'rb') as f:
    d_Rn_pole = pickle.load(f, encoding='latin1')
```

```python
bolos = hwm_pole.query(pydfmux.Bolometer)\
           .join(pydfmux.ChannelMapping, pydfmux.Wafer)\
           .filter(pydfmux.Wafer.name == 'w206')

lc_channels_hwm = {b.name: b.channel_map.lc_channel.channel for b in bolos}
freq_hwm = {b.name: b.channel_map.lc_channel.frequency for b in bolos}
```

```python
Rtotal_pole = {}
for mod in d_Rn_pole.keys():
    if 'pre_drop' in d_Rn_pole[mod]:
        for jchan in d_Rn_pole[mod]['pre_drop'].keys():
            if d_Rn_pole[mod]['subtargets'][jchan]['physical_name'].split('/')[0] == 'w206':
                bolo = d_Rn_pole[mod]['subtargets'][jchan]['bolometer']
                Rtotal_pole[bolo] = d_Rn_pole[mod]['pre_drop'][jchan]['R']
                
Rtotal_corrected_pole  = {bolo: Rtotal_pole[bolo] / tf[lc_channels_hwm[bolo]-1] \
                          for bolo in Rtotal_pole if bolo in lc_channels_hwm}
Rn_corrected_pole_dict = {bolo: Rtotal_corrected_pole[bolo] - Rp_model(freq_hwm[bolo]) \
                          for bolo in Rtotal_pole if bolo in freq_hwm}
Rn_corrected_pole      = np.array([Rtotal_corrected_pole[bolo] - Rp_model(freq_hwm[bolo]) \
                                   for bolo in Rtotal_pole if bolo in freq_hwm])
```

```python
# _ = plt.hist(list(Rtotal_pole.values()), bins=np.linspace(0,3,51))
# _ = plt.hist(list(Rn_pole.values()), bins=np.linspace(0,3,51))
_ = plt.hist(Rn_corrected_pole,
             bins=np.linspace(0,3,51),
             histtype='step')
_ = plt.hist(Rn_fnal,
             bins=np.linspace(0,3,51),
             histtype='step')
```

## $T_c$

```python
_ = plt.hist(Tc_fnal[np.isfinite(Tc_fnal)], bins=np.linspace(0.42,0.46,51))
cut_outliers = (Tc_fnal<0.45) & (Tc_fnal>0.43)
plt.title('$T_c = {:.0f} \pm {:.0f}$ mK'\
          .format(1e3*np.median(Tc_fnal[np.isfinite(Tc_fnal)]),
                  1e3*np.std(Tc_fnal[np.isfinite(Tc_fnal) & cut_outliers])))
plt.xlabel('$T_c$ [mK]')
plt.ylabel('bolometers')
```

### Combined plot for paper

```python
fig, ax = plt.subplots(1, 2, sharey=False, figsize=(7,3))

_ = ax[0].hist(list(Rn_corrected_pole),
               bins=np.linspace(0.5, 2.5, 51),
               histtype='stepfilled', alpha=0.5, color='C0')
_ = ax[0].hist(list(Rn_corrected_pole),
               bins=np.linspace(0.5, 2.5, 51),
               histtype='step', linewidth=1.5, color='C0')

_ = ax[1].hist(Tc_fnal[np.isfinite(Tc_fnal)],
               bins=np.linspace(0.42,0.46,51),
               histtype='stepfilled', alpha=0.5, color='C0')
_ = ax[1].hist(Tc_fnal[np.isfinite(Tc_fnal)],
               bins=np.linspace(0.42,0.46,51),
               histtype='step', linewidth=1.5, color='C0')

cut_Tc_outliers = (Tc_fnal<0.45) & (Tc_fnal>0.43)

ax[0].set_title('mean $R_n = {:.2f}$ Ohm\nstd $= {:.2f}$ Ohm'\
            .format(np.median(Rn_corrected_pole[np.isfinite(Rn_corrected_pole)]),
                    np.std(Rn_corrected_pole[np.isfinite(Rn_corrected_pole)])), fontsize=14)
ax[0].set_xlabel('$R_n$ [Ohm]', fontsize=14)
ax[0].set_ylabel('bolometers', fontsize=14)

ax[1].set_title('mean $T_c = {:.0f}$ mK\nstd $= {:.0f}$ mK'\
            .format(1e3*np.median(Tc_fnal[np.isfinite(Tc_fnal)]),
                    1e3*np.std(Tc_fnal[np.isfinite(Tc_fnal) & cut_Tc_outliers])), fontsize=14)
ax[1].set_xlabel('$T_c$ [mK]', fontsize=14)

for jplot in [0,1]:
    for tick in ax[jplot].xaxis.get_major_ticks():
        tick.label.set_fontsize(14)
    for tick in ax[jplot].yaxis.get_major_ticks():
        tick.label.set_fontsize(14)
        
plt.tight_layout()
plt.savefig('figures/Rn_Tc_combined.pdf')
```

```python
fig, ax = plt.subplots(1, 2, sharey=False, figsize=(7,3))

_ = ax[0].hist(list(Rn_corrected_pole),
               bins=np.linspace(0.5, 2.5, 51),
               histtype='stepfilled', alpha=0.5, color='C0')
_ = ax[0].hist(list(Rn_corrected_pole),
               bins=np.linspace(0.5, 2.5, 51),
               histtype='step', linewidth=1.5, color='C0')

_ = ax[1].hist(Tc_fnal[np.isfinite(Tc_fnal)],
               bins=np.linspace(0.42,0.46,51),
               histtype='stepfilled', alpha=0.5, color='C0')
_ = ax[1].hist(Tc_fnal[np.isfinite(Tc_fnal)],
               bins=np.linspace(0.42,0.46,51),
               histtype='step', linewidth=1.5, color='C0')

cut_Tc_outliers = (Tc_fnal<0.45) & (Tc_fnal>0.43)

ax[0].set_title('mean $R_n = {:.2f}$ Ohm\nstd $= {:.2f}$ Ohm'\
            .format(np.median(Rn_corrected_pole[np.isfinite(Rn_corrected_pole)]),
                    np.std(Rn_corrected_pole[np.isfinite(Rn_corrected_pole)])), fontsize=16)
ax[0].set_xlabel('$R_n$ [Ohm]', fontsize=16)
ax[0].set_ylabel('bolometers', fontsize=16)

ax[1].set_title('mean $T_c = {:.0f}$ mK\nstd $= {:.0f}$ mK'\
            .format(1e3*np.median(Tc_fnal[np.isfinite(Tc_fnal)]),
                    1e3*np.std(Tc_fnal[np.isfinite(Tc_fnal) & cut_Tc_outliers])), fontsize=16)
ax[1].set_xlabel('$T_c$ [mK]', fontsize=16)

for jplot in [0,1]:
    for tick in ax[jplot].xaxis.get_major_ticks():
        tick.label.set_fontsize(16)
    for tick in ax[jplot].yaxis.get_major_ticks():
        tick.label.set_fontsize(16)

plt.tight_layout()
plt.savefig('figures/Rn_Tc_combined_poster.pdf')
```

## $P_{sat}$
We operate the telescope at a base temperature of 315mK, so let's get the lab measurements of Psat and renormalize them to this temperature.

```python
path_psat = '/home/adama/SPT/spt_analysis/20190630_ltd/run33/GT_slots12_0135_0136'
fname_psat = 'fnal_run33_slots12_0135_0136_Rpcorr_G(T)_fit_results.pkl'
with open(os.path.join(path_psat, fname_psat), 'rb') as f:
    d_psat = pickle.load(f, encoding='latin1')
hwm = pydfmux.load_session(open('/home/adama/SPT/hardware_maps/fnal/run33/hwm.yaml', 'r'))['hardware_map']
bolos = hwm.query(pydfmux.Bolometer)
```

```python
freq_fnal = {'{}/{}'.format(b.wafer.name, b.physical_name): b.channel_map.lc_channel.frequency \
               for b in bolos if b.channel_map is not None}
lc_channel_fnal = {'{}/{}'.format(b.wafer.name, b.physical_name): b.channel_map.lc_channel.channel \
               for b in bolos if b.channel_map is not None}

def func_bias_corr(f, Lb, Rb):
    return np.sqrt((Rb**2 + (2*np.pi)**2 * (f**2) * (Lb**2)) / (Rb**2))

def func_Rp_corr(Rtotal, Rp):
    return (Rtotal - Rp) / Rtotal
    
Rb_canonical = 0.03
Lb_canonical = 0.9e-9
```

```python
psat_plot = np.array([d_psat[bolo]['Psat280_IV'] for bolo in d_psat])
f_plot = np.array([freq_fnal[bolo] for bolo in d_psat])
plt.plot(f_plot, psat_plot, '.')
plt.plot(f_plot, psat_plot * func_bias_corr(f_plot,
                                            Lb=Lb_canonical,
                                            Rb=Rb_canonical), '.')
```

```python
psat_fnal_315mK = {90:[], 150:[], 220:[]}
psat_fnal_280mK = {90:[], 150:[], 220:[]}
for bolo in d_psat.keys():
    band = int(bolo.split('/')[1].split('.')[1])
    psat_fnal_315mK[band].append( d_psat[bolo]['k_IV'] * \
                                 (d_psat[bolo]['Tc_IV']**d_psat[bolo]['n_IV'] - \
                                  0.315**d_psat[bolo]['n_IV'])*1e12 * \
                                 func_bias_corr(freq_fnal[bolo], Lb=Lb_canonical, Rb=Rb_canonical))
    psat_fnal_280mK[band].append( d_psat[bolo]['k_IV'] * \
                                 (d_psat[bolo]['Tc_IV']**d_psat[bolo]['n_IV'] - \
                                  0.280**d_psat[bolo]['n_IV'])*1e12 * \
                                 func_bias_corr(freq_fnal[bolo], Lb=Lb_canonical, Rb=Rb_canonical))
```

Next let's get measurements of the optical Psat from all of June 2019 for typical winter observing conditions. Note that the obsid range corresponding to June 2019 is 76118400 (June 1, 2019) to 78710400 (July 1, 2019).

```python
joule_path = '/spt/user/adama/20190630_ltd/downsampled/joulepower_ra0hdec-67.25*'
fnames = glob(joule_path)
fnames = np.sort(fnames)

psat_pole_315mK = {}
freq_pole = {}

obsid_june1 = 76118400
obsid_july1 = 78710400

for fname in fnames:
    obsid = int(os.path.basename(fname).split('_')[2].split('.')[0])
    
    if obsid > obsid_june1 and obsid < obsid_july1:
        print(obsid)
        djoule = list(core.G3File(fname))
        boloprops = djoule[0]["BolometerProperties"]
        wiringmap = djoule[1]["WiringMap"]
        hkmap = djoule[2]["DfMuxHousekeeping"]

        psat_pole_315mK[obsid] = {90:{}, 150:{}, 220:{}}
        freq_pole[obsid] = {90:{}, 150:{}, 220:{}}
        for bolo in boloprops.keys():
            if boloprops[bolo].wafer_id == 'w206' and \
               bolo in djoule[2]['AvgPower'].keys() and \
               boloprops[bolo].band/core.G3Units.GHz in psat_pole_315mK[obsid].keys():
                boardhk, mezzhk, modhk, chanhk = dfmux.HousekeepingForBolo(hkmap, wiringmap, bolo, True)
                bias_freq = chanhk.carrier_frequency/core.G3Units.Hz
                psat_pole_315mK[obsid][boloprops[bolo].band/core.G3Units.GHz][bolo] = \
                    djoule[2]['AvgPower'][bolo] / (1e-12*core.G3Units.watt) * \
                    func_bias_corr(bias_freq, Lb=Lb_canonical, Rb=Rb_canonical) * \
                    func_Rp_corr(chanhk.rfrac_achieved*chanhk.rnormal,
                                 Rp_model(bias_freq))
                freq_pole[obsid][boloprops[bolo].band/core.G3Units.GHz][bolo] = bias_freq
```

```python
band_label = {90:'95', 150:'150', 220:'220'}
fig, ax = plt.subplots(1,3, figsize=(10,3), sharey=True, num=1)
for jband, band in enumerate([90, 150, 220]):  
    psat_dict = {}
    freq_dict = {}
    for obsid in psat_pole_315mK:
        for bolo in psat_pole_315mK[obsid][band]:
            if bolo not in psat_dict:
                psat_dict[bolo] = []
                freq_dict[bolo] = []
            psat_dict[bolo].append(psat_pole_315mK[obsid][band][bolo])
            freq_dict[bolo].append(freq_pole[obsid][band][bolo])
            
    psat_pole_plot = [np.median(psat_dict[bolo]) for bolo in psat_dict]
    freq_pole_plot = [np.median(freq_dict[bolo]) for bolo in psat_dict]
    

    _ = ax[jband].hist(psat_pole_plot,
                       bins=np.linspace(0, 20, 41),
                       color='C{}'.format(jband), alpha=0.5,
                       label='optical (on-sky)',
                       normed=False)
    _ = ax[jband].hist(psat_pole_plot,
                       bins=np.linspace(0, 20, 41),
                       histtype='step', color='C{}'.format(jband),
                       normed=False)
    _ = ax[jband].hist(psat_fnal_315mK[band],
                       bins=np.linspace(0, 20, 41),
                       histtype='step', linestyle='--', color='k',
                       label='dark (lab)',
                       normed=False)
    print('{} GHz median dark Psat (280mK) = {:.1f}'.format(band, np.median(psat_fnal_280mK[band])))
    print('{} GHz median dark Psat (315mK) = {:.1f}'.format(band, np.median(psat_fnal_315mK[band])))
#     ax[jband].set_title('{:.2f} pW'.format(np.median(psat_fnal_315mK[band]) - \
#                                            np.median(psat_pole_plot)))
    ax[jband].set_title('{} GHz'.format(band_label[band]), fontsize=14)
    ax[jband].legend(frameon=False, fontsize=12)
    
    plt.figure(2)
    plt.plot(freq_pole_plot, psat_pole_plot, '.')
    
    for tick in ax[jband].xaxis.get_major_ticks():
        tick.label.set_fontsize(14)
    for tick in ax[jband].yaxis.get_major_ticks():
        tick.label.set_fontsize(14)

plt.figure(1)
ax[1].set_xlabel('saturation power [pW]', fontsize=14)
ax[0].set_ylabel('bolometers', fontsize=14)
plt.tight_layout()
plt.savefig('figures/psat_dark_vs_optical.pdf')

plt.figure(2)
plt.xlabel('bias frequency [Hz]')
plt.ylabel('Psat (corrected) [pW]')
plt.tight_layout()
plt.savefig('figures/psat_optical_vs_freq.pdf')
```

```python
psat_target_280mK = {90:10, 150:15, 220:20}

band_label = {90:'95', 150:'150', 220:'220'}
fig, ax = plt.subplots(1,3, figsize=(10,3), sharey=True, num=1)
for jband, band in enumerate([90, 150, 220]):  
    psat_dict = {}
    freq_dict = {}
    for obsid in psat_pole_315mK:
        for bolo in psat_pole_315mK[obsid][band]:
            if bolo not in psat_dict:
                psat_dict[bolo] = []
                freq_dict[bolo] = []
            psat_dict[bolo].append(psat_pole_315mK[obsid][band][bolo])
            freq_dict[bolo].append(freq_pole[obsid][band][bolo])
            
    psat_pole_plot = [np.median(psat_dict[bolo]) for bolo in psat_dict]
    freq_pole_plot = [np.median(freq_dict[bolo]) for bolo in psat_dict]
    

    _ = ax[jband].hist(psat_pole_plot,
                       bins=np.linspace(0, 20, 41),
                       color='C{}'.format(jband), alpha=0.5,
                       label='optical (on-sky)',
                       normed=False)
    _ = ax[jband].hist(psat_pole_plot,
                       bins=np.linspace(0, 20, 41),
                       histtype='step', color='C{}'.format(jband),
                       normed=False)
    _ = ax[jband].hist(psat_fnal_315mK[band],
                       bins=np.linspace(0, 20, 41),
                       histtype='step', linestyle='--', color='k',
                       label='dark (lab)',
                       normed=False)
    
    target_315mK = psat_target_280mK[band] * \
                   np.median(psat_fnal_315mK[band]) / np.median(psat_fnal_280mK[band])
    
    print('{} GHz median dark Psat = {:.2f} pW'.format(band, np.median(psat_fnal_315mK[band])))
    print('{} GHz median optical Psat = {:.2f} pW'.format(band, np.median(psat_pole_plot[band])))
    
    ax[jband].plot([target_315mK, target_315mK], [0,200],
                   'r--', linewidth=1, label='dark target')
    
    ax[jband].set_title('{} GHz'.format(band_label[band]), fontsize=16)
    ax[jband].legend()
    
    for tick in ax[jband].xaxis.get_major_ticks():
        tick.label.set_fontsize(16)
    for tick in ax[jband].yaxis.get_major_ticks():
        tick.label.set_fontsize(16)
    
    

plt.figure(1)
ax[1].set_xlabel('saturation power [pW]', fontsize=16)
ax[0].set_ylabel('bolometers', fontsize=16)
plt.ylim([0, 180])
plt.tight_layout()
plt.savefig('figures/psat_dark_vs_optical_poster.pdf')

```

## Optical Efficiency


### FNAL lab measurement


The analysis above is a little disjointed since it is split across multiple bits of code, and it's also not clear that systematic effects are actually handled in a self-consistent way (e.g. there may be double-counting of the wafer/stage systematic effect). Let's be pretty explicit about how the systematic corrections should be performed for the cold load optical efficiency measurement, and then redo everything from scratch in the code below. Denote the Psat data we measure $P_{sat,i}$ at temperatures $T_{cl,i}$. The Psat as a function of cold load temperature is given by
\begin{equation}
P_{sat}(T_{cl}) = P_{sat}^{dark}(T_{stage}(T_{cl})) - \eta P_{opt}(T_{cl}).
\end{equation}

1. The first "correction" is for the stage temperature variation as a function of the cold load temperature. There are two possible ways to account for this:
 1. On the one hand, we can calculate the dark saturation power using the measured dark $G(T)$ parameters. In other words, we have the substitution
\begin{equation}
P_{sat}^{dark}(T_{stage}(T_{cl})) = k (T_c^n - T_{stage}^n(T_{cl})),
\end{equation}
where the function $T_{stage}^n(T_{cl})$ is not explicitly known, but measured at each point, which is good enough for our purposes. We therefore have
\begin{equation}
P_{sat}(T_{cl}) = k (T_c^n - T_{stage}^n(T_{cl})) - \eta P_{opt}(T_{cl}).
\end{equation}

 1. On the other hand, we can estimate this effect using the pixels that are blanked off by the metal plate. Empirically, most of the dark pixels show a linear relationship between $P_{sat}$ and $T_{cl}$. We can therefore assume for a dark bolometer that
 \begin{equation}
 P_{sat}^{dark}(T_{stage}(T_{cl})) = P_0 - CT_{cl}.
 \end{equation}
 If we do this fit for all bolometers in a band and then take the average $\left< C \right>$, we can write the optical bolometer powers as:
 \begin{equation}
 P_{sat}(T_{cl}) = P_{sat}^{dark}(T_{stage}(0)) - \left< C \right> T_{cl} - \eta P_{opt}(T_{cl}).
 \end{equation}
 
1. The second systematic effect is for the bias inductance correction. For any power measured using the dfmux system, we make the replacement
\begin{equation}
P \rightarrow \frac{\sqrt{R_b^2 + (2\pi f L_b)^2}}{R_b} P
\end{equation}
Assuming that $P_{sat}$ and $P_{sat}^{dark}$ are saturation powers measured with pydfmux units, we have
\begin{equation}
P_{sat}(T_{cl}) = P_{sat}^{dark}(T_{stage}(0)) - \left< C \right> T_{cl} - \eta P_{opt}(T_{cl}) \frac{R_b^2}{R_b^2 + (2\pi f L_b)^2}.
\end{equation}

1. The final systmatic effect is due to the filter transmission. We can account for this naturally in the expression that we use for the optical power
\begin{equation}
P_{sat}(T_{cl}) = P_{sat}^{dark}(T_{stage}(0)) - \left< C \right> T_{cl} - \eta \frac{R_b}{\sqrt{R_b^2 + (2\pi f L_b)^2}} \int \frac{h \nu}{\exp{h\nu / kT} - 1} R_{ant}(\nu) R_{filt}(\nu) ~d\nu,
\end{equation}
where $R_{ant}$ is the response of the antenna, and $R_{filt}$ is the response of the filter. While I have written this as having some putative frequency dependence for the sake of generality, we will normally treat this as a constant.

```python
with open('20180926/20180925_201728_opteff_housekeeping.pkl', 'rb') as f:
    hk_data = pickle.load(f, encoding='latin1')
    
with open('run33/RT_slots123/fnal_run33__RT_data_for_Rpcorr.pkl', 'rb') as f:
    Rp_data = pickle.load(f, encoding='latin1')
    
hwm_fname = '/home/adama/SPT/hardware_maps/fnal/run33/hwm.yaml'
hwm = pydfmux.load_session(open(hwm_fname))['hardware_map']
bolos_fnal = hwm.query(pydfmux.Bolometer)
freqs_fnal = {'{}/{}'.format(b.wafer.name, b.physical_name): \
              b.channel_map.lc_channel.frequency for b in bolos_fnal \
              if b.channel_map is not None}

# parasitic circuit parameters
Rb = 0.03     # [Ohm]
Lb = 0.9e-9   # [H]

# filter transmission parameters
filter_data = [np.array([0, 1e12]), np.array([0.97**3, 0.97**3])]
```

```python
# load and wrangle housekeeping data
coldloadtemp = (np.array(hk_data['blackbody start temp']) +
                np.array(hk_data['blackbody stop temp'])) / 2.0
T_stage = {CLtemp: (hk_data['UC stage start temp'][jT] +
                    hk_data['UC stage stop temp'][jT]) / 2.0
           for jT,CLtemp in enumerate(coldloadtemp)}

drop_bolos_datadir = hk_data['drop_bolos datadir'][-1].lstrip('/daq/pydfmux_output/')
drop_bolos_pkl_files = [os.path.basename(fname)
                        for fname in glob('{}/data/*pkl'
                                               .format(drop_bolos_datadir))]
psat_of_Tcl = {} # data of Psat and T, keyed by bolo goes in here

# loop over temperatures and fit for Psat at each to fill psat_of_Tcl
for filename in drop_bolos_pkl_files:
    IV_datafiles = {CLtemp: '{}/data/{}'
                    .format(hk_data['drop_bolos datadir'][jT].lstrip('/daq/pydfmux_output/'), filename)
                    for jT,CLtemp in enumerate(coldloadtemp)}
    
    psat_data = calc_psat_data(IV_datafiles, Zp_data=None,
                               R_term=None, R_threshold=0.95)
    for bolo in psat_data: psat_of_Tcl[bolo] = psat_data[bolo]
```

Do the linear fit to the dark, blanked-off bolometers.

```python
# First find the list of bolometers that are in the fully "blanked-off" region.
# We define this as bolometers that are in the non-illuminated hextants and
# more than 2cm away from the center of the wafer.
blanked_iceboard = '0136'
model_params_blanked = {}
for bolo in psat_of_Tcl:
    pixelnum = int(bolo.split('.')[0].split('/')[1])
    pixel_xy = pxtools.pixelnum2XY([pixelnum])[0]
    r = np.sqrt(pixel_xy[0]**2 + pixel_xy[1]**2)
    
    if blanked_iceboard in str(psat_of_Tcl[bolo]['pstring']) and r>20:
        try:
            p = np.polyfit(psat_of_Tcl[bolo]['T'],
                           psat_of_Tcl[bolo]['Psat'], 1)
            model_params_blanked[bolo] = p
        except:
            print('Failed to fit {}'.format(bolo))
```

```python
mean_slopes_blanked = {}
for band in [90,150,220]:
    slopes = np.array([model_params_blanked[bolo][0] for bolo in model_params_blanked \
                          if '.{}.'.format(band) in bolo])
    _ = plt.hist(slopes[np.isfinite(slopes)]*1e12,
                 bins=np.linspace(-0.3, 0, 21),
                 histtype='step',
                 label='{} GHz'.format(band))
    mean_slopes_blanked[band] = np.mean(slopes[np.isfinite(slopes)])
plt.legend()
plt.xlabel('slope [pW/K]')
plt.ylabel('bolometers')
plt.title('"dark" response of blanked-off bolos to coldload')
plt.tight_layout()
```

Now do the fit to the full model for the optical detectors.

```python
model_params_optical = {}
for bolo in psat_of_Tcl:
    band = bolo.split('/')[1].split('.')[1]
    
    if '0135/2' in str(psat_of_Tcl[bolo]['pstring']):
        print(bolo)
        try:
            model_params_optical[bolo], fit_cov = \
                fit_efficiency(psat_of_Tcl[bolo]['T'],
                               psat_of_Tcl[bolo]['Psat'], 
                               freqs_fnal[bolo],
                               mean_slopes_blanked[int(band)],
                               band,
                               filter_data=filter_data,
                               Rb=Rb, Lb=Lb)
        except:
            print('Failed to fit {}'.format(bolo))
```

And finally make the plots of optical efficiency.

```python
plt.figure(1)
for band in [90,150,220]:
    eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                          if '.{}.'.format(band) in bolo])
    _ = plt.hist(eff[np.isfinite(eff)], bins=np.linspace(0,1,21),
                 histtype='step',
                 label='{} GHz'.format(band))
plt.legend()
plt.xlabel('optical efficiency')
plt.ylabel('bolometers')
plt.tight_layout()

band_legends = {90:95, 150:150, 220:220}
fig, ax = plt.subplots(1,3, figsize=(12,3), sharex=True, sharey=True, num=2)
for jband, band in enumerate([90, 150, 220]):
    eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                          if '.{}.'.format(band) in bolo])
    ax[jband].hist(eff, np.linspace(0, 1.2, 31),
                   label='{} GHz'.format(band), histtype='stepfilled',
                   alpha=0.3, color='C{}'.format(jband))
    ax[jband].hist(eff, np.linspace(0, 1.2, 31),
                   histtype='step',
                   color='C{}'.format(jband))
    ax[jband].set_title('{} GHz'.format(band_legends[band]))
ax[1].set_xlim([0, 1.2])
ax[0].set_ylabel('bolometers')
ax[1].set_xlabel('optical efficiency')
plt.tight_layout()
# plt.savefig('figures/fnal_optical_eff.pdf')

fig, ax = plt.subplots(1,4, figsize=(12,3.5), sharex=False, sharey=True, num=3,
                       gridspec_kw={'width_ratios': [3, 1,1,1]})
for band in [90,150,220]:
    eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                    if '.{}.'.format(band) in bolo])
    freq = np.array([freqs_fnal[bolo] for bolo in model_params_optical \
                     if '.{}.'.format(band) in bolo])
    ax[0].plot(freq[np.isfinite(eff)]*1e-6, eff[np.isfinite(eff)], 'o',
             label='{} GHz'.format(band_legends[band]))
ax[0].legend(fontsize=13)
ax[0].set_ylim([0,1.2])
ax[0].set_xlabel('bias frequency [MHz]', fontsize=15)
ax[0].set_ylabel('optical efficiency', fontsize=15)
ax[0].grid()

eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                if '.90.'.format(band) in bolo])
_ = ax[1].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', color='C0', alpha=0.5)
_ = ax[1].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', histtype='step', color='C0')
ax[1].set_title('95 GHz\nmean eff. = {:.2f}'.format(np.mean(eff)), fontsize=14)
ax[1].grid()

eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                if '.150.'.format(band) in bolo])
_ = ax[2].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', color='C1', alpha=0.5)
_ = ax[2].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', histtype='step', color='C1')
ax[2].set_xlabel('bolometers', fontsize=15)
ax[2].set_title('150 GHz\nmean eff. = {:.2f}'.format(np.mean(eff)), fontsize=15)
ax[2].grid()

eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                if '.220.'.format(band) in bolo])
_ = ax[3].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', color='C2', alpha=0.5)
_ = ax[3].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', histtype='step', color='C2')
ax[3].set_title('220 GHz\nmean eff. = {:.2f}'.format(np.mean(eff)), fontsize=14)
ax[3].grid()

for jband in [0,1,2,3]:
    for tick in ax[jband].xaxis.get_major_ticks():
        tick.label.set_fontsize(15)
    for tick in ax[jband].yaxis.get_major_ticks():
        tick.label.set_fontsize(15)

plt.tight_layout()
plt.savefig('figures/fnal_optical_eff.pdf')
```

```python
fig, ax = plt.subplots(1,4, figsize=(12,3.5), sharex=False, sharey=True, num=3,
                       gridspec_kw={'width_ratios': [3, 1,1,1]})
band_legends = {90:95, 150:150, 220:220}
for band in [90,150,220]:
    eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                    if '.{}.'.format(band) in bolo])
    freq = np.array([freqs_fnal[bolo] for bolo in model_params_optical \
                     if '.{}.'.format(band) in bolo])
    ax[0].plot(freq[np.isfinite(eff)]*1e-6, eff[np.isfinite(eff)], 'o',
             label='{} GHz'.format(band_legends[band]))
ax[0].legend()
ax[0].set_ylim([0,1.2])
ax[0].set_xlabel('bias frequency [MHz]', fontsize=16)
ax[0].set_ylabel('optical efficiency', fontsize=16)
ax[0].grid()

eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                if '.90.'.format(band) in bolo])
_ = ax[1].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', color='C0', alpha=0.5)
_ = ax[1].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', histtype='step', color='C0')
ax[1].set_title('95 GHz\nmean eff. = {:.0f}%'.format(100*np.mean(eff)), fontsize=16)
ax[1].grid()

eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                if '.150.'.format(band) in bolo])
_ = ax[2].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', color='C1', alpha=0.5)
_ = ax[2].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', histtype='step', color='C1')
ax[2].set_xlabel('bolometers', fontsize=16)
ax[2].set_title('150 GHz\nmean eff. = {:.0f}%'.format(100*np.mean(eff)), fontsize=16)
ax[2].grid()

eff = np.array([model_params_optical[bolo][1] for bolo in model_params_optical \
                if '.220.'.format(band) in bolo])
_ = ax[3].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', color='C2', alpha=0.5)
_ = ax[3].hist(eff, bins=np.linspace(0, 1.2, 31),
               orientation='horizontal', histtype='step', color='C2')
ax[3].set_title('220 GHz\nmean eff. = {:.0f}%'.format(100*np.mean(eff)), fontsize=16)
ax[3].grid()

for jband in [0,1,2,3]:
    for tick in ax[jband].xaxis.get_major_ticks():
        tick.label.set_fontsize(16)
    for tick in ax[jband].yaxis.get_major_ticks():
        tick.label.set_fontsize(16)
        
plt.tight_layout()
plt.savefig('figures/fnal_optical_eff_poster.pdf')
```

Lastly, let's make plots of the data by bolometer to check for fit quality.

```python
# plots of fits to blanked-off bolometers

T_plot = np.linspace(0, 18, 20)
for jplot, pstring in enumerate(np.unique([psat_of_Tcl[bolo]['pstring'] for bolo in psat_of_Tcl])):
    if '0136' in pstring:
        plt.figure(jplot+1, figsize=(30,20))
        jsubplot = 1
        for bolo in psat_of_Tcl:
            band = bolo.split('/')[1].split('.')[1]
            if pstring == psat_of_Tcl[bolo]['pstring']:
                plt.subplot(8,8,jsubplot+1)
                plt.plot(psat_of_Tcl[bolo]['T'],
                         psat_of_Tcl[bolo]['Psat']*1e12,
                         'ko')
                if bolo in model_params_blanked:
                    plt.plot(T_plot, np.polyval(model_params_blanked[bolo], T_plot)*1e12)
                plt.xlim([7, 17])
                plt.grid()
                plt.title(bolo)

                jsubplot+=1
        plt.tight_layout()
        plt.savefig('figures/{}_dark_psat_vs_temp.png'.format(pstring.replace('/', '_')), dpi=150)
        plt.close()
```

```python
# plots of fits to optical bolometers

T_plot = np.linspace(0, 18, 20)
for jplot, pstring in enumerate(np.unique([psat_of_Tcl[bolo]['pstring'] for bolo in psat_of_Tcl])):
    if '0135/2' in pstring:
        plt.figure(jplot+1, figsize=(30,20))
        jsubplot = 1
        for bolo in psat_of_Tcl:
            band = bolo.split('/')[1].split('.')[1]
            if pstring == psat_of_Tcl[bolo]['pstring']:
                plt.subplot(8,8,jsubplot+1)
                plt.plot(psat_of_Tcl[bolo]['T'],
                         psat_of_Tcl[bolo]['Psat']*1e12,
                         'ko')
                if bolo in model_params_optical:
                    psat_plot = PsatofT_coldload(T_plot,
                                                 model_params_optical[bolo][0],
                                                 freqs_fnal[bolo],
                                                 mean_slopes_blanked[int(band)],
                                                 model_params_optical[bolo][1],
                                                 band,
                                                 filter_data=filter_data,
                                                 Rb=Rb, Lb=Lb)
                    plt.plot(T_plot, psat_plot*1e12)
                    plt.annotate('Psat = {:.1f}'.format(1e12*model_params_optical[bolo][0]),
                                 xy=(.05,.4), xycoords='axes fraction')
                    plt.annotate('$\eta$ = {:.3f}'.format(model_params_optical[bolo][1]),
                                 xy=(.05,.3), xycoords='axes fraction')
                plt.xlim([7, 17])
                plt.grid()
                plt.title(bolo)

                jsubplot+=1
        plt.tight_layout()
        plt.savefig('figures/{}_optical_psat_vs_temp.png'.format(pstring.replace('/', '_')), dpi=150)
        plt.close()
```

## NETs
Bill pointed out that if NET is our metric for the optical performance of this wafer, then we should include numerical values in the manuscript compared with the rest of the receiver. Let's calculate the median NETs for June 2019 here.

```python
obsid_june1 = 76118400
obsid_july1 = 78710400
nets = {}
net_units = core.G3Units.K * np.sqrt(core.G3Units.sec)

noise_dir_raw = '/spt/data/bolodata/fullrate/noise/'
noise_dir = '/spt/user/production/calibration/noise'
fnames = np.sort(glob(os.path.join(noise_dir, '*g3')))
for fname in fnames:
    obsid = int(os.path.basename(fname).rstrip('.g3'))
    if obsid >= obsid_june1 and obsid < obsid_july1:
        print(fname)
        fname_cal = '{}/{}/offline_calibration.g3'.format(noise_dir_raw, obsid)
        d = list(core.G3File(fname))
        draw = list(core.G3File(os.path.join(fname_cal)))
        boloprops = draw[0]["BolometerProperties"]
        net_map = d[0]["NET_3.0Hz_to_5.0Hz"]
        
        nets[obsid] = {}
        for bolo in net_map.keys():
            if bolo in boloprops.keys():
                wafer = boloprops[bolo].wafer_id
                if wafer not in nets[obsid]:
                    nets[obsid][wafer] = {90:[], 150:[], 220:[]}
                band = boloprops[bolo].band / core.G3Units.GHz
                nets[obsid][wafer][band].append(net_map[bolo] / net_units)
```

```python
for band in [90, 150, 220]:
    n = np.hstack([nets[obsid]['w206'][band] \
                  for obsid in nets.keys() if 'w206' in nets[obsid].keys()])
    n = n[np.isfinite(n)]*1e6
    plt.hist(n, bins=np.linspace(0,3500,41),
             label='{} GHz, median = {:.0f}'.format(band, np.median(n)))
plt.legend()
```

```python
for band in [90, 150, 220]:
    n = np.hstack([nets[obsid][wafer][band] \
                  for obsid in nets.keys() for wafer in nets[obsid].keys() \
                  if wafer != 'w206'])
    n = n[np.isfinite(n)]*1e6
    plt.hist(n, bins=np.linspace(0,3500,41),
             label='{} GHz, median = {:.0f}'.format(band, np.median(n)))
plt.legend()
```

```python
bolos_pole = hwm_pole.query(pydfmux.Bolometer)
freqs_pole = {b.name: b.channel_map.lc_channel.frequency \
              for b in bolos_pole \
              if b.channel_map is not None and \
              b.channel_map.lc_channel.frequency > 1.e5}
```

```python
d = list(core.G3File('/spt/user/production/calibration/noise/76698219.g3'))
net_map = d[0]["NET_3.0Hz_to_5.0Hz"]
freqs_plot = [freqs_pole[bolo] for bolo in net_map.keys() if bolo in freqs_pole]
net_plot = [net_map[bolo] / (1e-6*core.G3Units.kelvin * np.sqrt(core.G3Units.second)) \
            for bolo in net_map.keys() if bolo in freqs_pole]
plt.plot(freqs_plot, net_plot, '.', markersize=1)
plt.ylim([0, 3000])
plt.xlabel('frequency [Hz]')
plt.ylabel('NET [uK rtsec]')
plt.tight_layout()
plt.savefig('figures/net_vs_freq.png', dpi=150)
```

```python
net_plot
```

```python

```
