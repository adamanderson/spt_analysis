---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: Python 3 (v2)
    language: python
    name: python3-v2
---

# Analysis for 2019 LTD Proceedings: W206 performance

```python
import numpy as np
import matplotlib.pyplot as plt
import pickle
from glob import glob
import re
import pydfmux
import pydfmux.analysis.utils.pixel_tools as pxtools
from spt3g import core, calibration, dfmux
import os.path
import adama_utils
import pandas as pd
```

```python
import pydfmux
hwm = pydfmux.load_session(open('/home/adama/SPT/hardware_maps_southpole/2019'
                                '/hwm_pole/hwm.yaml'))['hardware_map']
```

## Yield
Daniel reports statistics for the following yield categories:
* wired bolometers
* room temperature connectivity
* identified resonance
* biased
* optically responsive

Let's estimate similar statistics just for W206.


### total detectors
We only measure detectors that are wired, so let's take the denominator to be only the detectors that we can measure.

```python
n_detectors = 66*24 - 6*2 # subtract off channels that go to alignment pixels
print('total number of detectors = {}'.format(n_detectors))
```

### warm pinout

```python
n_opens = 130 # from spreadshee on trac wiki: compare_all_wafers_to_last_year_19Nov2018.xlsx
n_connected = n_detectors - n_opens
print('total detectors passing warm pinout = {:.0f} ({:.1f}%)'\
      .format(n_connected,\
              100 * n_connected / n_detectors))
```

### identified resonances

```python
hwm_fname = '/home/adama/SPT/hardware_maps_southpole/2019/hwm_pole/hwm.yaml'
hwm = pydfmux.load_session(open(hwm_fname, 'r'))['hardware_map']
```

```python
bolos_w206 = hwm.query(pydfmux.Bolometer)\
                .join(pydfmux.ChannelMapping, pydfmux.Wafer)\
                .filter(pydfmux.Wafer.name=='w206')
freqs = [b.channel_map.lc_channel.frequency \
         for b in bolos_w206 \
         if b.channel_map.lc_channel.frequency > 1.e5]
n_resonances = len(freqs)
print('number of bolometers with matched resonances = {:.0f} ({:.1f}%)'\
      .format(n_resonances, 100 * n_resonances / n_detectors))
```

### tuned detectors

```python
tuned_fnames = []
for dirstub in ['201905', '201906']:
    fnames = glob('/big_scratch/pydfmux_output/{}*/'
                  '*drop_bolos_*/data/TOTAL_DATA.pkl'.format(dirstub))
    tuned_fnames += [fname for fname in fnames if 'tweak' not in fname]

```

```python
ntuned = {}
for fname in tuned_fnames:
    with open(fname, 'rb') as f:
        print(fname)
        ntuned[fname] = 0
        
        d = pickle.load(f)
        for mod in d.keys():
            if type(d[mod])==dict and 'results_summary' in d[mod].keys():
                physical_names = [d[mod]['subtargets'][chan]['physical_name'] \
                              for chan in d[mod]['subtargets'].keys()]
                if np.any(['w206' in physname for physname in physical_names]):
                    ntuned[fname] += d[mod]['results_summary']['ntuned']
```

```python
n_tuned_median = np.median(list(ntuned.values()))
print('median number of tuned bolometers = {:.0f} ({:.1f}%)'\
      .format(n_tuned_median, 100 * n_tuned_median / n_detectors))
```

What accounts for the large drop in number of detectors between showing a resonance and being tuned? The most likely cut is the HR10 network analysis cut. Let's calculate the number of these detectors that are on w206.

```python
df = pd.read_csv('/home/adama/SPT/hardware_maps_southpole/2019/global/exclude/warmVcold_exclude_hr10.csv')
bolos_w206 = hwm.query(pydfmux.Bolometer)\
                .join(pydfmux.ChannelMapping, pydfmux.Wafer)\
                .filter(pydfmux.Wafer.name == 'w206')
bolonames_w206 = [b.name for b in bolos_w206]
bolonames_w206_hr10 = [bolo for bolo in df['name'] if bolo in bolonames_w206]
print('# of bolos removed by HR10 cut = {:.1f} ({:.1f}%)'\
      .format(len(bolonames_w206_hr10),
              100 * len(bolonames_w206_hr10) / n_detectors))
```

### optically responsive
For simplicity, let's bypass the autoprocessing data and just pull numbers from the data quality monitoring, which uses a S/N cut for 20 (median S/N is 200, so this is a low bar for optical responsitivity).

```python
fnames = glob('/spt/data/rsync/spt_dq_data/201905*_data_cache.pkl')

alivebolos = {90:[], 150:[], 220:[]}

for fname in fnames:
    with open(fname, 'rb') as f:
        d = pickle.load(f)
    for obsid in d['calibrator'].keys():
        if 'AliveBolosCal_4Hz' in d['calibrator'][obsid].keys():
            alivebolos[90].append(d['calibrator'][obsid]['AliveBolosCal_4Hz']['w206'][90])
            alivebolos[150].append(d['calibrator'][obsid]['AliveBolosCal_4Hz']['w206'][150])
            alivebolos[220].append(d['calibrator'][obsid]['AliveBolosCal_4Hz']['w206'][220])

for band in alivebolos:
    print('# bolos with calibrator S/N > 20 at {} GHz = {:.0f}'.format(band, np.median(alivebolos[band])))
total_alive = np.sum([np.median(alivebolos[band]) for band in alivebolos])
print('# total bolos alive = {:.0f} ({:.1f}%)'\
      .format(total_alive, 100*total_alive / n_detectors))
```

## Time Constants

```python
tau_dir = '/spt/user/panz/data/time_constant_results/2019/'
fnames = glob(os.path.join(tau_dir, 'time_const*_el_*deg.pkl'))
```

```python
# get the bolometer properties
boloprops = list(core.G3File('/spt/data/bolodata/fullrate/calibrator/76410413'
                             '/offline_calibration.g3'))[0]["BolometerProperties"]
```

```python
tau = {}
tau_el67 = {}

for fname in fnames:
    with open(fname, 'rb') as f:
        d = pickle.load(f)
        
    for bolo in d.keys():
        if bolo in boloprops and boloprops[bolo].wafer_id == 'w206':
            if bolo not in tau.keys():
                tau[bolo] = {}
            tau[bolo][os.path.basename(fname).lstrip('time_const')[:8]] = d[bolo][0]
            
            if '67deg' in fname:
                if bolo not in tau_el67.keys():
                    tau_el67[bolo] = {}
                tau_el67[bolo][os.path.basename(fname).lstrip('time_const')[:8]] = d[bolo][0]
```

```python
for jband, band in enumerate([90, 150, 220]):
    plt.figure(jband+1)
    tau_plot1 = np.array([np.median(tau[bolo]['73570880']) for bolo in tau \
                         if boloprops[bolo].band/core.G3Units.GHz==band and \
                         '73570880' in tau[bolo].keys()])
    tau_plot2 = np.array([np.median(tau[bolo]['78191553']) for bolo in tau \
                         if boloprops[bolo].band/core.G3Units.GHz==band and \
                         '78191553' in tau[bolo].keys()])
    _ = plt.hist(1e3*tau_plot1, bins=np.linspace(0, 12, 41),
                 histtype='step', label='{} GHz'.format(band),
                 linestyle='--', color='C{}'.format(jband))
    _ = plt.hist(1e3*tau_plot2, bins=np.linspace(0, 12, 41),
                 histtype='step', label='{} GHz'.format(band),
                 color='C{}'.format(jband))
plt.legend()
```

```python
bandlabel = {90:'95', 150:'150', 220:'220'}
plt.figure(figsize=(5,3))
for jband, band in enumerate([90, 150, 220]):
    tau_plot = np.array([np.median([tau_el67[bolo][obsid] for obsid in tau_el67[bolo].keys()]) for bolo in tau_el67 \
                         if boloprops[bolo].band/core.G3Units.GHz==band and \
                         '78121319' in tau[bolo].keys()])
    print(np.mean(tau_plot)*1000)
    _ = plt.hist(1e3*tau_plot, bins=np.linspace(0, 12, 26),
                 histtype='stepfilled', label='{} GHz'.format(bandlabel[band]),
                 alpha=0.5, color='C{}'.format(jband))
    _ = plt.hist(1e3*tau_plot, bins=np.linspace(0, 12, 26),
                 histtype='step', linewidth=1.5, color='C{}'.format(jband))
plt.legend(frameon=False)
plt.xlabel('time constant [msec]')
plt.ylabel('bolometers')
plt.tight_layout()
plt.savefig('figures/tau.pdf')
```

## Noise vs. power
Attempt to reproduce Fig. 3 of 1811.08287. Let's first figure out how to get the Joule power from the housekeeping data.

```python
fname_joule = '/spt/user/adama/20190630_ltd/fullrate/joulepower_noise_77198612.g3'
djoule = list(core.G3File(fname_joule))
boloprops = djoule[0]["BolometerProperties"]
dautoproc = list(core.G3File('/spt/user/production/calibration/noise/77198612.g3'))[0]
```

```python
PJ = {90:[], 150:[], 220:[]}
NET = {90:[], 150:[], 220:[]}
NEP = {90:[], 150:[], 220:[]}

for bolo in boloprops.keys():
    if boloprops[bolo].wafer_id == 'w206' and \
       bolo in djoule[1]['AvgPower'].keys() and \
       bolo in dautoproc["NET_3.0Hz_to_5.0Hz"] and \
       boloprops[bolo].band/core.G3Units.GHz in PJ.keys():
        PJ[boloprops[bolo].band/core.G3Units.GHz].append(fr['AvgPower'][bolo] / (1e-12*core.G3Units.watt))
        NET[boloprops[bolo].band/core.G3Units.GHz].append(dautoproc["NET_3.0Hz_to_5.0Hz"][bolo] / \
                                                          (1e-6*core.G3Units.kelvin * np.sqrt(core.G3Units.second)))
```

```python
for band in PJ:
    _ = plt.hist(PJ[band], bins=np.linspace(2, 15, 51), histtype='step', label='{} GHz'.format(band))
plt.legend(frameon=False)
plt.xlabel('$P_J$ [pW]')
plt.ylabel('bolometers')
plt.tight_layout()
```

```python
for band in PJ:
    plt.plot(PJ[band], NET[band], '.')
plt.legend(frameon=False)
plt.xlabel('$P_J$ [pW]')
plt.ylabel('bolometers')
plt.tight_layout()
plt.ylim([0, 2500])
```

```python
joule_path = '/spt/user/adama/20190630_ltd/fullrate/'
fnames = glob(os.path.join(joule_path, '*'))
fnames = np.sort(fnames)

PJ = {}
NET = {}
NEP = {}
#90:[], 150:[], 220:[]

for fname in fnames:
    obsid = os.path.basename(fname).split('_')[2].split('.')[0]
    print(obsid)
    djoule = list(core.G3File(fname))
    boloprops = djoule[0]["BolometerProperties"]
    dautoproc = list(core.G3File('/spt/user/production/calibration/'
                                 'noise/{}.g3'.format(obsid)))[0]
    
    PJ[obsid] = {90:[], 150:[], 220:[]}
    NET[obsid] = {90:[], 150:[], 220:[]}
    NEP[obsid] = {90:[], 150:[], 220:[]}
    for bolo in boloprops.keys():
        if boloprops[bolo].wafer_id == 'w206' and \
           bolo in djoule[1]['AvgPower'].keys() and \
           bolo in dautoproc["NET_3.0Hz_to_5.0Hz"] and \
           boloprops[bolo].band/core.G3Units.GHz in PJ[obsid].keys():
            PJ[obsid][boloprops[bolo].band/core.G3Units.GHz]\
                .append(djoule[1]['AvgPower'][bolo] / (1e-12*core.G3Units.watt))
            NET[obsid][boloprops[bolo].band/core.G3Units.GHz]\
                .append(dautoproc["NET_3.0Hz_to_5.0Hz"][bolo] / \
                        (1e-6*core.G3Units.kelvin * np.sqrt(core.G3Units.second)))
            NEP[obsid][boloprops[bolo].band/core.G3Units.GHz]\
                .append(dautoproc["NEP_3.0Hz_to_5.0Hz"][bolo] / \
                        (1e-18*core.G3Units.watt / np.sqrt(core.G3Units.Hz)))
```

```python
for band in [90, 150, 220]:
    PJ_median = np.array([np.median(PJ[obsid][band]) \
                          for obsid in PJ if int(obsid)>72000000])
    NET_median = np.array([np.median(NET[obsid][band]) \
                           for obsid in PJ if int(obsid)>72000000])
    plt.plot(PJ_median, NET_median, '.')
    plt.axis([4, 10, 0, 2500])
```

```python
for jband, band in enumerate([90, 150, 220]):
    plt.figure(jband+1)
    PJ_plot = np.hstack([PJ[obsid][band] for obsid in PJ])
    NET_plot = np.hstack([NET[obsid][band] for obsid in PJ])
    
    binedges = np.linspace(4,9,26)
    bincenters = (binedges[:-1] + binedges[1:]) / 2
    ind = np.digitize(PJ_plot, bins=binedges)
    NET_median = np.array([np.median(NET_plot[(ind==jbin) & (NET_plot<3000)]) \
                             for jbin in range(len(bincenters))])
    NET_yerr_up = np.array([np.percentile(NET_plot[(ind==jbin) & (NET_plot<3000)], 84) \
                   for jbin in range(len(bincenters))])
    NET_yerr_down = np.array([np.percentile(NET_plot[(ind==jbin) & (NET_plot<3000)], 16) \
                   for jbin in range(len(bincenters))])
    NET_err = np.array([np.std(NET_plot[(ind==jbin) & (NET_plot<3000)]) \
                        / np.sqrt(len(NET_plot[(ind==jbin) & (NET_plot<3000)])) \
                      for jbin in range(len(bincenters))]) 
    
    
    plt.plot(PJ_plot, NET_plot, '.', markersize=0.1)
    plt.errorbar(bincenters, NET_median, NET_err, color='k')
    plt.axis([0, 15, 0, 2200])
```

```python
from scipy.stats import gaussian_kde

net_modes = []
pj_modes = []
obsid_list = []
for obsid in NET.keys():
    net_plot = np.linspace(0,3000,1000)
    pj_plot = np.linspace(0,15,1000)
    net_analyze = np.array(NET[obsid][220])
    pj_analyze = np.array(PJ[obsid][220])
    
    try:
        kernel = gaussian_kde(net_analyze[np.isfinite(net_analyze)])
        net_modes.append(net_plot[np.argmax(kernel(net_plot))])
        obsid_list.append(int(obsid))
        
        kernel = gaussian_kde(pj_analyze[np.isfinite(pj_analyze)])
        pj_modes.append(pj_plot[np.argmax(kernel(pj_plot))])
    except:
        pass
```

```python
plt.plot(pj_modes, net_modes, '.')
# plt.axis([5, 9, 1000, 2500])
```

```python
plt.plot(obsid_list, pj_modes, '.')
```

## $R_n$ and $R_p$

```python
with open('/home/adama/SPT/spt_analysis/20190630_ltd/run33/RT_slots123/fnal_run33__RT_data.pkl', 'rb') as f:
    d = pickle.load(f, encoding='latin1')
with open('res_tf.pkl', 'rb') as f:
    tf = pickle.load(f)
```

```python
Rn_fnal = np.array([d['Rn'][bolo] for bolo in d['Rn']])
Rp_fnal = np.array([d['Rp'][bolo] for bolo in d['Rn']])
fbias_fnal = np.array([d['bias_freq'][bolo] for bolo in d['Rn']])
Tc_fnal = np.array([d['Tc_average'][bolo] for bolo in d['Tc_average']])

fbias_fnal = fbias_fnal[np.isfinite(Rn_fnal)]
Rp_fnal = Rp_fnal[np.isfinite(Rn_fnal)]
Rn_fnal = Rn_fnal[np.isfinite(Rn_fnal)]
```

To deal with the fact that we don't have measurements of $R_p$ on every detector in the pole data, let's estimate an average frequency-dependent stray impedance from the lab data, which we can subtract off from each detector.

```python
Rp_tofit = Rp_fnal[(Rp_fnal<0.7) & (Rp_fnal>0) & (fbias_fnal<5.5e6)]
fbias_tofit = fbias_fnal[(Rp_fnal<0.7) & (Rp_fnal>0) & (fbias_fnal<5.5e6)]
plt.plot(fbias_tofit, Rp_tofit, '.')
Rp_coeff = np.polyfit(fbias_tofit, Rp_tofit, deg=8)

def Rp_model(f):
    f = np.asarray(f)
    Rp = np.zeros(f.shape)
    Rp[f<min(fbias_tofit)] = np.polyval(Rp_coeff, min(fbias_tofit))
    Rp[f>max(fbias_tofit)] = np.polyval(Rp_coeff, max(fbias_tofit))
    Rp[(f>min(fbias_tofit)) & (f<max(fbias_tofit))] = \
        np.polyval(Rp_coeff, f[(f>min(fbias_tofit)) & (f<max(fbias_tofit))])
    return Rp
    
fbias_fit = np.linspace(1200000, 6000000)
plt.plot(fbias_fit, Rp_model(fbias_fit))
plt.savefig('Rp_vs_fbias.png', dpi=200)
```

Our use of a single, frequency-dependent value for $R_p$ introduces some residual variance in the estimate of $R_n$. Let's try to estimate that systematic uncertainty by computing the residuals between the lab $R_p$ data and our model.

```python
residual = Rp_model(fbias_tofit) - Rp_tofit
plt.plot(fbias_tofit, residual, '.')
plt.xlabel('frequency [Hz]')
plt.ylabel('residual in $R_p$ fit')
plt.title('std of residual = {:.3f} Ohm'.format(np.std(residual)))
plt.tight_layout()
```

Below is the correction factor for the normal resistance that was estimated as a function of LC index by Daniel Dutcher. This is the same correction factor, $c(i(f))$ that is discussed in Appendix A of his LTD proceedings 1809.00033. To apply it, we compute
$$
R_n^{corr} = \frac{R^{meas}_{total}}{c(i)} - R^{meas}_p,
$$
where $R^{meas}_{total}$ is the measured total resistance reported by pydfmux, $R^{meas}_p$ is the measured parasitic resistance reported by pydfmux, and $c$ is Daniel's correction factor, which is a function of the LC index $i$ corresponding to the channel of interest.

Note that Daniel actually computed his corrected resistance as
$$
R_n^{corr} = \frac{R^{meas}_{total} - R^{meas}_p}{c(i)}.
$$
These two estimators give very similar results, but I think the former is slightly better. The reason is that we believe the correction factor to be a result of the parasitic capacitance to ground at the LC, which occurs before the TES. This means that the parasitic and the TES act like a current divider. When the TES resistance is large relative to the parasitic, a large fraction of the current gets shunted away from the SQUID causing the measured "impedance" to appear large. When the TES is superconducting, the relative size of the correction is much smaller. The fact that we don't see any obvious splitting of the impedance by LC orientation in the preceding figure suggests that the correction factor is small when the TES is superconducting. The former correction prescription should be closer to this case.

```python
plt.plot(tf, '.')
```

In order to apply the resistance correction, we need to know the LC index of a resonator. We don't know this perfectly from the Fermilab data because the matching is less reliable than at pole. As a result, we take the normal resistance measurements from a representative pole tuning, and extract the LC index from the hardware map.

```python
fname_Rn_pole = '/big_scratch/pydfmux_output/20190618/20190619_011150_drop_bolos_228/data/TOTAL_DATA.pkl'
with open(fname_Rn_pole, 'rb') as f:
    d_Rn_pole = pickle.load(f, encoding='latin1')
```

```python
bolos = hwm.query(pydfmux.Bolometer)\
           .join(pydfmux.ChannelMapping, pydfmux.Wafer)\
           .filter(pydfmux.Wafer.name == 'w206')

lc_channels_hwm = {b.name: b.channel_map.lc_channel.channel for b in bolos}
freq_hwm = {b.name: b.channel_map.lc_channel.frequency for b in bolos}
```

```python
Rtotal_pole = {}
for mod in d_Rn_pole.keys():
    if 'pre_drop' in d_Rn_pole[mod]:
        for jchan in d_Rn_pole[mod]['pre_drop'].keys():
            if d_Rn_pole[mod]['subtargets'][jchan]['physical_name'].split('/')[0] == 'w206':
                bolo = d_Rn_pole[mod]['subtargets'][jchan]['bolometer']
                Rtotal_pole[bolo] = d_Rn_pole[mod]['pre_drop'][jchan]['R']
                
Rtotal_corrected_pole = {bolo: Rtotal_pole[bolo] / tf[lc_channels_hwm[bolo]-1] for bolo in Rtotal_pole}
Rn_corrected_pole_dict = {bolo: Rtotal_corrected_pole[bolo] - Rp_model(freq_hwm[bolo]) for bolo in Rtotal_pole}
Rn_corrected_pole = np.array([Rtotal_corrected_pole[bolo] - Rp_model(freq_hwm[bolo]) for bolo in Rtotal_pole])
```

```python
# _ = plt.hist(list(Rtotal_pole.values()), bins=np.linspace(0,3,51))
# _ = plt.hist(list(Rn_pole.values()), bins=np.linspace(0,3,51))
_ = plt.hist(Rn_corrected_pole,
             bins=np.linspace(0,3,51),
             histtype='step')
_ = plt.hist(Rn_fnal,
             bins=np.linspace(0,3,51),
             histtype='step')
```

## $T_c$

```python
_ = plt.hist(Tc[np.isfinite(Tc)], bins=np.linspace(0.42,0.46,51))
cut_outliers = (Tc<0.45) & (Tc>0.43)
plt.title('$T_c = {:.0f} \pm {:.0f}$ mK'\
          .format(1e3*np.median(Tc[np.isfinite(Tc)]),
                  1e3*np.std(Tc[np.isfinite(Tc) & cut_outliers])))
plt.xlabel('$T_c$ [mK]')
plt.ylabel('bolometers')
```

### Combined plot for paper

```python
fig, ax = plt.subplots(1, 2, sharey=False, figsize=(7,3))

_ = ax[0].hist(list(Rn_corrected_pole),
               bins=np.linspace(0.5, 2.5, 51),
               histtype='stepfilled', alpha=0.5, color='C0')
_ = ax[0].hist(list(Rn_corrected_pole),
               bins=np.linspace(0.5, 2.5, 51),
               histtype='step', linewidth=1.5, color='C0')

_ = ax[1].hist(Tc[np.isfinite(Tc)],
               bins=np.linspace(0.42,0.46,51),
               histtype='stepfilled', alpha=0.5, color='C0')
_ = ax[1].hist(Tc[np.isfinite(Tc)],
               bins=np.linspace(0.42,0.46,51),
               histtype='step', linewidth=1.5, color='C0')

cut_Tc_outliers = (Tc<0.45) & (Tc>0.43)

ax[0].set_title('mean $R_n = {:.2f}$ Ohm\nstd $= {:.2f}$ Ohm'\
            .format(np.median(Rn_corrected_pole[np.isfinite(Rn_corrected_pole)]),
                    np.std(Rn_corrected_pole[np.isfinite(Rn_corrected_pole)])))
ax[0].set_xlabel('$R_n$ [Ohm]')
ax[0].set_ylabel('bolometers')

ax[1].set_title('mean $T_c = {:.0f}$ mK\nstd $= {:.0f}$ mK'\
            .format(1e3*np.median(Tc[np.isfinite(Tc)]),
                    1e3*np.std(Tc[np.isfinite(Tc) & cut_Tc_outliers])))
ax[1].set_xlabel('$T_c$ [mK]')

plt.tight_layout()
plt.savefig('figures/Rn_Tc_combined.pdf')
```

## $P_{sat}$
We operate the telescope at a base temperature of 315mK, so let's get the lab measurements of Psat and renormalize them to this temperature.

```python
path_psat = '/home/adama/SPT/spt_analysis/20190630_ltd/run33/GT_slots12_0135_0136'
fname_psat = 'fnal_run33_slots12_0135_0136_Rpcorr_G(T)_fit_results.pkl'
with open(os.path.join(path_psat, fname_psat), 'rb') as f:
    d_psat = pickle.load(f, encoding='latin1')
hwm = pydfmux.load_session(open('/home/adama/SPT/hardware_maps/fnal/run33/hwm.yaml', 'r'))['hardware_map']
bolos = hwm.query(pydfmux.Bolometer)
```

```python
freq_fnal = {'{}/{}'.format(b.wafer.name, b.physical_name): b.channel_map.lc_channel.frequency \
               for b in bolos if b.channel_map is not None}
lc_channel_fnal = {'{}/{}'.format(b.wafer.name, b.physical_name): b.channel_map.lc_channel.channel \
               for b in bolos if b.channel_map is not None}

def func_bias_corr(f, Lb, Rb):
    return (Rb**2 + (2*np.pi)**2 * (f**2) * (Lb**2)) / (Rb**2)

Rb_canonical = 0.03
Lb_canonical = 0.6e-9
```

```python
psat_plot = np.array([d_psat[bolo]['Psat280_IV'] for bolo in d_psat])
f_plot = np.array([freq_fnal[bolo] for bolo in d_psat])
plt.plot(f_plot, psat_plot, '.')
plt.plot(f_plot, psat_plot * func_bias_corr(f_plot,
                                            Lb=Lb_canonical,
                                            Rb=Rb_canonical), '.')
```

```python
psat_fnal_315mK = {90:[], 150:[], 220:[]}
psat_fnal_280mK = {90:[], 150:[], 220:[]}
for bolo in d_psat.keys():
    band = int(bolo.split('/')[1].split('.')[1])
    psat_fnal_315mK[band].append( d_psat[bolo]['k_IV'] * \
                                 (d_psat[bolo]['Tc_IV']**d_psat[bolo]['n_IV'] - \
                                  0.315**d_psat[bolo]['n_IV'])*1e12 * \
                                 func_bias_corr(freq_fnal[bolo], Lb=0.6e-9, Rb=0.03))
    psat_fnal_280mK[band].append( d_psat[bolo]['k_IV'] * \
                                 (d_psat[bolo]['Tc_IV']**d_psat[bolo]['n_IV'] - \
                                  0.280**d_psat[bolo]['n_IV'])*1e12 * \
                                 func_bias_corr(freq_fnal[bolo], Lb=0.6e-9, Rb=0.03))
```

Next let's get measurements of the optical Psat from all of June 2019 for typical winter observing conditions. Note that the obsid range corresponding to June 2019 is 76118400 (June 1, 2019) to 78710400 (July 1, 2019).

```python
joule_path = '/spt/user/adama/20190630_ltd/downsampled/joulepower_ra0hdec-67.25*'
fnames = glob(joule_path)
fnames = np.sort(fnames)

psat_pole_315mK = {}
freq_pole = {}

obsid_june1 = 76118400
obsid_july1 = 78710400

for fname in fnames:
    obsid = int(os.path.basename(fname).split('_')[2].split('.')[0])
    
    if obsid > obsid_june1 and obsid < obsid_july1:
        print(obsid)
        djoule = list(core.G3File(fname))
        boloprops = djoule[0]["BolometerProperties"]
        wiringmap = djoule[1]["WiringMap"]
        hkmap = djoule[2]["DfMuxHousekeeping"]

        psat_pole_315mK[obsid] = {90:{}, 150:{}, 220:{}}
        freq_pole[obsid] = {90:{}, 150:{}, 220:{}}
        for bolo in boloprops.keys():
            if boloprops[bolo].wafer_id == 'w206' and \
               bolo in djoule[2]['AvgPower'].keys() and \
               boloprops[bolo].band/core.G3Units.GHz in psat_pole_315mK[obsid].keys():
                boardhk, mezzhk, modhk, chanhk = dfmux.HousekeepingForBolo(hkmap, wiringmap, bolo, True)
                bias_freq = chanhk.carrier_frequency/core.G3Units.Hz
                psat_pole_315mK[obsid][boloprops[bolo].band/core.G3Units.GHz][bolo] = \
                    djoule[2]['AvgPower'][bolo] / (1e-12*core.G3Units.watt) * \
                    func_bias_corr(bias_freq, Lb=Lb_canonical, Rb=Rb_canonical)
                freq_pole[obsid][boloprops[bolo].band/core.G3Units.GHz][bolo] = bias_freq
```

```python
band_label = {90:'95', 150:'150', 220:'220'}
fig, ax = plt.subplots(1,3, figsize=(10,3), sharey=True, num=1)
for jband, band in enumerate([90, 150, 220]):  
    psat_dict = {}
    freq_dict = {}
    for obsid in psat_pole_315mK:
        for bolo in psat_pole_315mK[obsid][band]:
            if bolo not in psat_dict:
                psat_dict[bolo] = []
                freq_dict[bolo] = []
            psat_dict[bolo].append(psat_pole_315mK[obsid][band][bolo])
            freq_dict[bolo].append(freq_pole[obsid][band][bolo])
            
    psat_pole_plot = [np.median(psat_dict[bolo]) for bolo in psat_dict]
    freq_pole_plot = [np.median(freq_dict[bolo]) for bolo in psat_dict]
    
#     _ = ax[jband].hist(psat_pole_315mK['70344984'][band],
#                        bins=np.linspace(0, 18, 41),
#                        color='C{}'.format(jband), alpha=0.5,
#                        label='{} GHz on-sky'.format(band),
#                        normed=False)
#     _ = ax[jband].hist(psat_pole_315mK['70344984'][band],
#                        bins=np.linspace(0, 18, 41),
#                        histtype='step', color='C{}'.format(jband),
#                        normed=False)
    _ = ax[jband].hist(psat_pole_plot,
                       bins=np.linspace(0, 20, 41),
                       color='C{}'.format(jband), alpha=0.5,
                       label='optical (on-sky)',
                       normed=False)
    _ = ax[jband].hist(psat_pole_plot,
                       bins=np.linspace(0, 20, 41),
                       histtype='step', color='C{}'.format(jband),
                       normed=False)
    _ = ax[jband].hist(psat_fnal_315mK[band],
                       bins=np.linspace(0, 20, 41),
                       histtype='step', linestyle='--', color='k',
                       label='dark (lab)',
                       normed=False)
#     ax[jband].set_title('{:.2f} pW'.format(np.median(psat_fnal_315mK[band]) - \
#                                            np.median(psat_pole_plot)))
    ax[jband].set_title('{} GHz'.format(band_label[band]))
    ax[jband].legend()
    
    plt.figure(2)
    plt.plot(freq_pole_plot, psat_pole_plot, '.')

plt.figure(1)
ax[1].set_xlabel('saturation power [pW]')
ax[0].set_ylabel('bolometers')
plt.tight_layout()
plt.savefig('figures/psat_dark_vs_optical.pdf')

plt.figure(2)
plt.xlabel('bias frequency [Hz]')
plt.ylabel('Psat (corrected) [pW]')
plt.tight_layout()
```

## Optical Efficiency


### FNAL lab measurement


Let's be pretty explicit about how the systematic corrections should be performed for the cold load optical efficiency measurement. Denote the Psat ddata we measure $P_{sat,i}$ at temperatures $T_{cl,i}$. The Psat as a function of cold load temperature is given by
\begin{equation}
P_{sat}(T_{cl}) = P_{sat}(T_{cl}=0, T_{stage}) - \eta P_{opt}(T_{cl}).
\end{equation}
The first systematic effect to account for is that $T_{stage}$ is not constant, but can vary with $T_{cl}$. So we write functionally
\begin{equation}
P_{sat}(T_{cl}) = P_{sat}(T_{cl}=0, T_{stage}(T_{cl})) - \eta P_{opt}(T_{cl}).
\end{equation}
We can trivially rearrange
\begin{equation}
P_{sat}(T_{cl}) + P_{sat}(T_{cl}=0, T_{ref}) - P_{sat}(T_{cl}=0, T_{stage}(T_{cl})) = P_{sat}(T_{cl}=0, T_{ref}) - \eta P_{opt}(T_{cl}).
\end{equation}
This may seem weird, but it reflects how the analysis is done in the code. We correct the measured Psats so that we can fit to a linear model without knowing the functional form of $T_{stage}(T_{cl})$.

Next, there is the possibility that the temperature of the detector wafer is different than the stage themometer, we correct for this by fitting a linear slope to the dark detectors. This implicitly assumes that the gradient effect is a linear bias to the saturation power
\begin{equation}
P_{sat}(T_{cl}) + P_{sat}(T_{cl}=0, T_{ref}) - P_{sat}(T_{cl}=0, T_{stage}(T_{cl})) = P_{sat}(T_{cl}=0, T_{ref}) - \eta P_{opt}(T_{cl}) - \lambda T_{cl}.
\end{equation}

```python
with open('run33/opticaleff/fnal_run33_slots12_0135_0136_optical_eff_fit_results.pkl', 'rb') as f:
    d = pickle.load(f, encoding='latin1')
    
# demangle bolonames
for bolo in d:
    d[bolo]['pstring'] = np.ndarray.tostring(d[bolo]['pstring']).decode("utf-8")

dark_pixels = [271, 250, 225, 196, 163]

slopes_optical = dict()
slopes_optical_corrected = dict()
efficiency_optical = dict()
efficiency_optical_corrected = dict()
freqs_optical = dict()
slopes_blanked = dict()
slopes_blanked_outer = dict()
slopes_dark = dict()
median_slopes_blanked_outer = dict()
fbias_fnal_opteff = dict()
for band in [90, 150, 220]:
    slopes_optical[band] = np.array([d[bolo]['slope_CL'] for bolo in d
                                     if str(d[bolo]['pstring']).split('/')[0] == '0135' and
                                        str(d[bolo]['pstring']).split('/')[1] == '2' and
                                        bolo.split('.')[1] == str(band)])
    efficiency_optical[band] = np.array([d[bolo]['opteff_CL'] for bolo in d
                                     if str(d[bolo]['pstring']).split('/')[0] == '0135' and
                                        str(d[bolo]['pstring']).split('/')[1] == '2' and
                                        bolo.split('.')[1] == str(band)])
    freqs_optical[band] = np.array([hwm.channel_maps_from_pstring(bolo)[0].lc_channel.frequency for bolo in d
                                     if str(d[bolo]['pstring']).split('/')[0] == '0135' and
                                        str(d[bolo]['pstring']).split('/')[1] == '2' and
                                        bolo.split('.')[1] == str(band)])
    slopes_blanked[band] = np.array([d[bolo]['slope_CL'] for bolo in d
                                     if str(d[bolo]['pstring']).split('/')[0] == '0136' and
                                        bolo.split('.')[1] == str(band)])
    slopes_dark[band] = np.array([d[bolo]['slope_CL'] for bolo in d
                                     if bolo.split('.')[1] == str(band) and
                                     int(bolo.split('.')[0].split('/')[1]) in dark_pixels])
    fbias_fnal_opteff[band] = np.array([freq_fnal[bolo] for bolo in d
                                        if str(d[bolo]['pstring']).split('/')[0] == '0135' and
                                           str(d[bolo]['pstring']).split('/')[1] == '2' and
                                           bolo.split('.')[1] == str(band)])

    slopes_blanked_outer[band] = np.array([])
    for bolo in d:
        pixelnum = int(bolo.split('.')[0].split('/')[1])
        pixel_xy = pxtools.pixelnum2XY([pixelnum])[0]
        r = np.sqrt(pixel_xy[0]**2 + pixel_xy[1]**2)
        
        if str(d[bolo]['pstring']).split('/')[0] == '0136' and \
           bolo.split('.')[1] == str(band) and r>20.:
            slopes_blanked_outer[band] = np.append(slopes_blanked_outer[band], d[bolo]['slope_CL'])
    median_slopes_blanked_outer[band] = np.median(slopes_blanked_outer[band])

    slopes_optical_corrected[band] = slopes_optical[band] - median_slopes_blanked_outer[band]
    efficiency_optical_corrected[band] = efficiency_optical[band] * \
                                         slopes_optical_corrected[band] / \
                                         slopes_optical[band] * \
                                         func_bias_corr(fbias_fnal_opteff[band],
                                                        Lb=Lb_canonical,
                                                        Rb=Rb_canonical)
```

```python
for jband, band in enumerate([90, 150, 220]):
    plt.plot(fbias_fnal_opteff[band],
             efficiency_optical[band],
             'C{}o'.format(jband), alpha=0.5, fillstyle='none',
             label='{} GHz, uncorrected'.format(band))
    plt.plot(fbias_fnal_opteff[band],
             efficiency_optical_corrected[band],
             'C{}+'.format(jband),
             label='{} GHz, gradient and Lb correction'.format(band))
    
plt.legend(frameon=False)
plt.xlabel('bias frequency [Hz]')
plt.ylabel('optical efficiency')
plt.tight_layout()
```

```python
fig, ax = plt.subplots(1,3, figsize=(10,3), sharex=True, sharey=True, num=1)
for jband, band in enumerate([90, 150, 220]):
    ax[jband].hist(efficiency_optical_corrected[band], np.linspace(0, 1.2, 21),
                   label='{} GHz'.format(band), histtype='stepfilled',
                   alpha=0.3, color='C{}'.format(jband))
    ax[jband].hist(efficiency_optical_corrected[band], np.linspace(0, 1.2, 21),
                   histtype='step',
                   color='C{}'.format(jband))
    ax[jband].set_title('{} GHz'.format(band))
ax[1].set_xlim([0, 1.2])
ax[0].set_ylabel('bolometers')
ax[1].set_xlabel('optical efficiency')
plt.tight_layout()
plt.savefig('figures/fnal_optical_eff.pdf')
```

### pole optical efficiency

```python
d = list(core.G3File('/spt/data/bolodata/downsampled/ra0hdec-52.25/76842533/offline_calibration.g3'))[0]
```

```python
rcw38_abs_cal = {
    90.0*core.G3Units.GHz: 4.0549662e-07*core.G3Units.K,
    150.0*core.G3Units.GHz: 2.5601153e-07*core.G3Units.K,
    220.0*core.G3Units.GHz: 2.8025804e-07*core.G3Units.K
}

bolos_cal_response = list(d["CalibratorResponse"].keys())
bolos_flux_cal = list(d["RCW38FluxCalibration"].keys())
bolos_int_flux = list(d["RCW38IntegralFlux"].keys())
opteff = {}

fig, ax = plt.subplots(1,3, figsize=(10,3), sharex=True, sharey=True, num=1)
for jband, band in enumerate([90, 150, 220]):
    opteff[band] = []
    for bolo in d["BolometerProperties"].keys():
        if d["BolometerProperties"][bolo].wafer_id == 'w206' and \
           d["BolometerProperties"][bolo].band/core.G3Units.GHz == band and \
           bolo in bolos_cal_response and \
           bolo in bolos_flux_cal and \
           bolo in bolos_int_flux and \
           bolo in freq_pole[76914614][band].keys():
            cal_response.append(d["CalibratorResponse"][bolo])
            flux_cal.append(d["RCW38FluxCalibration"][bolo])
            int_flux.append(d["RCW38IntegralFlux"][bolo])
            opteff[band].append(-1 * d["CalibratorResponse"][bolo] * \
                                     d["RCW38FluxCalibration"][bolo] * \
                                     d["RCW38IntegralFlux"][bolo] / \
                                     rcw38_abs_cal[band*core.G3Units.GHz] / \
                                     adama_utils.wattsPerKcmb(band*core.G3Units.GHz))
                                     
            
    ax[jband].hist(opteff[band], bins=np.linspace(0, 1, 41),
                   histtype='step')
plt.tight_layout()
```

```python
0.5/1.36
```

```python

```
